## 正規表現 (Regular expression)

### 正規表現とは
パターンを指定して文字列検索や置き換えを行う一種のミニ言語。
正規表現はRubyだけでなく、他の言語やテキストエディタでも使われている。

* Rubyにおける正規表現オブジェクト
* 正規表現そのものの使い方

上記2点が知識として必要となる。

### 正規表現の便利さ

```
text = <<TEXT
I love Ruby.
Python is a great language.
Java and JavaScript are different.
TEXT
text.scan(/[A-Z][A-Za-z]+/) #=> ["Ruby", "Python", "Java", "JavaScript"]
```

.scan(/[A-Z][A-Za-z]+/)の部分が正規表現。

#### 正規表現学習資料
[詳説 正規表現 第3版](https://www.oreilly.co.jp/books/9784873113593/)
[初心者歓迎！手と目で覚える正規表現入門・その１「さまざまな形式の電話番号を検索しよう」](https://qiita.com/jnchito/items/893c887fbf19e17d3ff9)
[初心者歓迎！手と目で覚える正規表現入門・その２「微妙な違いを許容しつつ置換しよう」](https://qiita.com/jnchito/items/64c3fdc53766ac6f2008)
[初心者歓迎！手と目で覚える正規表現入門・その３「空白文字を自由自在に操ろう」](https://qiita.com/jnchito/items/6f0c885c1c4929092578)
[初心者歓迎！手と目で覚える正規表現入門・その４（最終回）「中級者テクニックをマスターしよう」](https://qiita.com/jnchito/items/b0839f4f4651c29da408)

#### 正規表現のメタ文字の例

| メタ文字  | 意味 |
|---|---|
|[]  |いずれか1文字を表す文字クラスを作る  |
|[^ ]  |~以外の任意の1文字を表す文字クラスを作る  |
|-   |[]内で使われる文字の範囲を表す  |
|.  |任意の1文字を表す  |
|()  |内部でマッチした文字列をキャプチャもしくはグループ化する  |
|?  |直前の文字やパターンが1回、もしくは0回現れる  |
|*  |直前の文字やパターンが0回以上連続する  |
|+  |直前の文字やパターンが1回以上連続する  |
|{n,m}  |直前の文字やパターンがn回以上、n回以下連続する  |
||  |OR条件を作る  |
|^  |行頭を表す  |
|$  |行末を表す  |
|\  |メタ文字をエスケープしたり、\nや\wといった他のメタ文字の一部になったりする  |

### Rubyにおける正規表現オブジェクト

正規表現リテラルというスラッシュでパターンを囲んで作成する。(/正規表現/)
正規表現はRegexpクラスのオブジェクト

正規表現と文字列の比較に「=~」を使用する。
マッチした場合、マッチした文字列の開始位置を返す。

```
'123-4567' =~ /\d{3}-\d{4}/
#=> 0
```

マッチしない場合、nilとなる。

```
'hello' =~ /\d{3}-\d{4}/
#=> nil
```

if文と=~の組み合わせでマッチしたか判定。

```
if '123-4567' =~ /\d{3}-\d{4}/
  puts 'マッチしました'
else
  puts 'マッチしませんでした'
end
#=> マッチしました
```

左辺に正規表現を置いてもOK。

```
/\d{3}-\d{4}/ =~ '123-4567'
#=> 0
/\d{3}-\d{4}/ =~ 'hello'
#=> nil
```

!~で真偽判定

```
'hello' !~ /\d{3}-\d{4}/
#=> true
'123-4567' !~ /\d{3}-\d{4}/
#=> false
```

#### ※Rubularとは

文字列が正規表現にマッチするか視覚的に確認するツール。

[Rubular公式サイト](https://rubular.com/)

### 正規表現のキャプチャ

"1977" "7" "17"の3つの文字列を抜きだす。
文字列が正規表現にマッチすると、MatchDataオブジェクトがかえってくる。(マッチしないとnil)
matchメソッドなStringクラスとRegexpクラスの両方に定義されている。

```
text = '私の誕生日は1977年7月17日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
m[1] #=> "1977"
m[2] #=> "7"
m[3] #=> "17"
```

条件分岐の中で真偽判定とローカル変数への代入例。

```
text = '私の誕生日は1977年7月17日です。'
# 真偽値の判定とローカル変数への代入を同時にやってしまう
if m = /(\d+)年(\d+)月(\d+)日/.match(text)
  # マッチした場合の処理（ローカル変数のmを使う）
else
  # マッチしなかった場合の処理
end
```

#### キャプチャに命名する。
キャプチャには(?<name>)というメタ文字を使って名前をつけることができる。

```
text = '私の誕生日は1977年7月17日です。'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text) # シンボルで名前を指定

m[:year]
#=> "1977"
m[:month]
#=> "7"
m[:day]
#=> "17"

# 文字列で指定も可能
m['year']
#=> "1977"

# 連番で指定も可能
m[2]
#=> "7"
```

また名前付きキャプチャはm、左辺に正規表現リテラルを右辺に文字列をおいて=~演算子を使うと
キャプチャの名前がローカル変数に割り当てられる。

※この場合、正規表現が右辺に来るとローカル変数は作成できない。
※正規表現オブジェクトが変数に入ってる場合も無効。

```
text = '私の誕生日は1977年7月17日です。'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  puts "#{year}/#{month}/#{day}" #=> 1977/7/17
end
```

### 正規表現とStringクラスのメソッド

#### scan
引数で渡した正規表現にマッチする部分を配列に入れる。

```
'1977年7月17日 2016年12月31日'.scan(/\d+年\d+月\d+日/)
#=> ["1977年7月17日", "2016年12月31日"]
```

#### [], slice, slice!
[]に正規表現を渡すと、文字列から正規表現にマッチした部分を抜きだす。

```
text = '郵便番号は123-4567です'
text[/\d{3}-\d{4}/] #=> "123-4567"

text = '郵便番号は123-4567です'
text.slice(/\d{3}-\d{4}/)
#=> "123-4567"
```

#### split
splitに正規表現を渡すと、マッチした文字列を区切り文字にして文字列に分解、その後配列として返す。

```
text = '123,456-789'

# 正規表現を使ってカンマまたはハイフンを区切り文字に指定。
text.split(/,|-/)
#=> ["123", "456", "789"]
```

#### gsub, gsub!
gsubメソッドを使用すると、第一引数の正規表現にマッチした文字列を第二引数の文字列で置き換える。

```
text = '123,456-789'
text.gsub(',', ':')
#=> "123:456-789"

# 正規表現を渡すと、マッチした部分を第2引数で置き換える
text.gsub(/,|-/, ':')
#=> "123:456:789"
```

### 正規表現オブジェクトを作成する様々な方法

#### Regexp.new
//の代わりとなる正規表現の作成方法

```
# /\d{3}-\d{4}/と同じ
Regexp.new('\d{3}-\d{4}')
```

#### %r(%記法)

```
# %rを使うとスラッシュをエスケープしなくてよい
%r!http://example\.com!

# !ではなく{}を区切り文字にする
%r{http://example\.com}
```

### caseでの正規表現

```
text = '03-1234-5678'

case text
when /^\d{3}-\d{4}$/
  puts '郵便番号です'
when /^\d{4}\/\d{1,2}\/\d{1,2}$/
  puts '日付です'
when /^\d+-\d+-\d+$/
  puts '電話番号です'
end
```

### /正規表現/オプション

#### iオプション
アルファベットの大文字小文字の違いを無視する。

```
/hello/i === 'HELLO'
#=> true
```

#### mオプション
任意の文字を表す.が改行文字にもマッチする。

```
/Hello.Bye/m === "Hello\nBye"
#=> true
```

#### xオプション
空白文字を無視する。＃を使って正規表現にコメントできるようになる。

```
regexp = /
  \d{3} # 郵便番号の先頭3桁
  -     # 区切り文字のハイフン
  \d{4} # 郵便番号の末尾4桁
/x
regexp === '123-4567'
#=> true
```

### 組み込み変数での結果取得
$で始まる特殊な変数を組み込み変数という。

=~やmatchメソッドを使うと、いくつかの組み込み変数にマッチした結果が代入される。

```
text = '私の誕生日は1977年7月17日です。'
text =~ /(\d+)年(\d+)月(\d+)日/

# MatchDataオブジェクトを取得
$~
#=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">

# マッチした部分全体を取得
$&
#=> "1977年7月17日"

# 1番目～3番目のキャプチャを取得
$1
#=> "1977"
$2
#=> "7"
$3
#=> "17"

# 最後のキャプチャ文字列を取得
$+
#=> "17"
```

### Regexp.last_match
組み込み変数のように、=~演算子などで最後にマッチした結果を取得できる。

```
text = '私の誕生日は1977年7月17日です。'
text =~ /(\d+)年(\d+)月(\d+)日/
Regexp.last_match
#=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
```

### match?メソッド
文字列が正規表現にマッチすればtrue, マッチしなければfalse

```
/\d{3}-\d{4}/.match?('123-4567')
#=> true
```