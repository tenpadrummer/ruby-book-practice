## ハッシュやシンボル

### ハッシュ({})
キーと値の組み合わせでデータを管理するオブジェクト。連想配列と呼ばれたりする。
ハッシュはHashクラスのオブジェクト。

### ハッシュの要素と追加、変更、取得
ハッシュ[キー] = 値で要素を追加できる。
キーに既存の値がある場合、要素が上書きされる。

ハッシュ[キー]で値を取り出す。存在しないキーを指定するとnilになる。

### ハッシュを使った繰り返し
eachメソッドで、キーと値を順に取り出せる。

```
currencies = {"japan" => "yen", "usa" => "dollar"}
currencies.each do |key, value|
  puts "#{key}: #{value}"
end
```
上記でブロック引数を1つにすると、キーと値が配列として格納される。

### ハッシュの同値比較、要素数の取得うm、要素の削除
==でハッシュを比較し、同じハッシュかチェックが可能。

size(またはlength)メソッドを使うとハッシュの要素の個数を調べることができる。

deleteメソッドで指定したキーに対応する要素を削除できる。指定したキーがなければnilが返ってくる。

### シンボル
シンボルは文字列とは別物あり、任意の文字列と一対一に対応するオブジェクト。
コロン(:)に続けて任意の名前を定義する。

```
:apple
:japan

'apple'
'japan'

シンボルと文字列はよく似ている。
```

### シンボルと文字列の違い
* シンボルはSymbolオブジェクト。Rubyでは内部で整数として管理されるため、見た目は文字列中身は整数。文字列はStringオブジェクト。そのため文字列よりも高速に処理ができる。

* シンボルは「同じシンボルであれば全く同じオブジェクト」となる。(object_idを使用すれば調べることができる)
文字列より、シンボルの方がメモリの使用効率がよくなる。

* シンボルはイミュータブルなオブジェクトのため、文字列のように破壊的な変更はできない。

### シンボルの特徴のまとめ
1. 表面上は文字列のように見える、そのため理解しやすい。
2. 実態は整数なので、高速に値を比較できる。
3. 同じシンボルは同じオブジェクトなので、メモリの使用効率が良い。
4. イミュータブルなので、勝手に値が変えられることがない。

### ハッシュのキーにシンボルを使用する
ハッシュのキーは文字列よりシンボルが優れている。
コロンの位置が変わるため、記述に注意。

### キーや値に異なるデータ型を含ませる
ハッシュに格納する値は、異なるデータ型が混在することがよくある。

```
person {name: "Alice", age: 21, friends: ["Bob", "John"], address: {mobile: "08012345678"}}
```

### メソッドのキーワード引数とハッシュ
キーワード引数は呼び出し時に自由に順番を入れ替えることができる。

 ```
 def メソッド(キーワード引数1: デフォルト値1, キーワード引数2: デフォルト値2)
 end
 ```

### ハッシュで使用頻度の高いメソッド

* keys: ハッシュのキーを配列として返す。
* values: ハッシュ値を配列として返す。
* has_key?(/key?/include?/member?): ハッシュの中に指定されたキーが存在するか確認する。
* **(またはmergeメソッド)をハッシュの前につけると、ハッシュ内で他のハッシュのキーと値を展開できる。

### メソッド呼び出し時の{}の省略
最後の引数がハッシュであれば、ハッシュリテラルの{}を省略できる。

### ハッシュの{}とブロックの[]
Rubyではメソッド呼び出しの()を省略できる。
しかしメソッドの第一引数にハッシュを渡す場合、()が必要となる。

### to_aとto_hメソッド
ハッシュにto_aメソッドを使用すると配列に変換が可能。
配列にto_hメソッドを使用するとハッシュに変換が可能。

```
currencies = { japan: 'yen', us: 'dollar', india: 'rupee' }
currencies.to_a #=> [[:japan, "yen"], [:us, "dollar"], [:india, "rupee"]]

array = [[:japan, "yen"], [:us, "dollar"], [:india, "rupee"]]
array.to_h #=> {:japan=>"yen", :us=>"dollar", :india=>"rupee"}
```

### ハッシュの初期値
Hash.newの引数として初期値を指定した場合、初期値として毎回同じオブジェクトが返ってくる。

```
h = Hash.new { 'hello' }
a = h[:foo] #=> "hello"
b = h[:bar] #=> "hello"
```

### シンボル作成の様々な方法
コロンに続けて、変数名やクラス名、メソッド名の識別子として有効な文字列を書く。
シングルクオートで囲ってもシンボルとして有効。
ダブルクオートを使用すると式展開が可能となる。

```
:apple
:Apple
:ruby_is_fun
:okay?
:welcome!
:_secret
:$dollar
:@at_mark

以下のようにシンボルを作るとエラー
:12345       #=> SyntaxError
:ruby-is-fun #=> NameError
:ruby is fun #=> SyntaxError
:()          #=> SyntaxError
```

### %記法でシンボルやシンボルの配列作成
％sでシンボルを作成可能
改行文字や式展開するなら%Iを使用。

```
%s!'ruby is fun.'!  #=> :"'ruby is fun.'"
%s('ruby is fun!') #=> :"'ruby is fun!'"
```

### シンボルと文字列の関係
to_symメソッド(intern)を使用すると、文字列をシンボルに変換できる。
to_sメソッド(id2name)を使用すると、シンボルにを文字列に変換できる。
respond_to?メソッドは、オブジェクトに対し文字列またはシンボルで指定した名前のメソッドが呼べるか調べる。

```
'apple'.respond_to?('include?')
'apple'.respond_to?(:include?)
```

### メソッド定義時の引数の並ぶ順番
1. 通常の引数
2. デフォルト値付きの引数
3. 可変長引数(1つ)
4. 通常の引数
5. キーワード引数
6. **を使った任意のキーワード引数
7. &をつかったブロックを受け取る引数

### よく使うイディオム1
【条件分岐で変数へ代入 / &.演算子】

```
def show_currency(country)
  if currency = find_currency(country)
    currency.upcase
  end
end
```
nil以外のオブジェクトならa.upcaseと書いた場合と同じ結果
nilだったらnilを返す(エラーにはならない)

```
a = 'foo'
a&.upcase
#=> "FOO"

a = nil
a&.upcase
#=> nil
```

### よく使うイディオム2
【||=を使った自己代入】
〇〇がnilまたはfalseならば、■を代入する。

```
limit ||= 10

limit = nil
limit ||= 10
limit
#=> 10
```

### よく使うイディオム3
【!!をつかった真偽値の型変換】
!!は「確実にtrueまたはfalseを返す」ためのもの。
（一度！で否定し、さらに!で結果を反転させる）

```
def user_exists?
  !!find_user
end
```
