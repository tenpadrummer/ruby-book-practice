## 配列や繰り返し処理

### 配列 ([])
複数データをまとめて格納できるオブジェクト。
配列データは順番に並んでおり、インデックスを指定することでそのデータを取得可能。
配列にはどんなオブジェクトでも格納できる。もちろん配列に配列も可能。

#### 配列の変更、追加、削除、多重代入
添字([配列](添字))を指定して値を代入すると、指定した要素を変更できる
<<で配列の際以後に要素を追加できる。
delete_atメソッドで配列の特定の位置にある要素を削除できる。
a,b = [1,2]といったように配列を使って多重代入できる。
割り算の賞とあまりを配列で返すdivmodメソッドの使用時、配列の多重代入が便利。

### ブロック
メソッドの引数として返すことのできる処理のかたまり。ブロック内で記述した処理は、必要におじてメソッドから呼び出される。

#### eachメソッド
配列に対して繰り返すよう処理するeachメソッド。配列の要素を最初から最後まで順場に取り出す。
取り出したものをブロックを使用し扱う。

#### deleteメソッド
配列に対し指定した条件に一致する要素を削除するメソッド。

#### delete_ifメソッド
eachと同じように配列に対し処理を行う。
ブロックに対し処理の戻り値をチェックする。その値が真ならブロックに渡した値を配列から削除、偽なら配列に残しておく。

### ブロック引数とブロック内変数
ブロック引数の名前はなんでもよい。
ブロック内の変数は変数のスコープ（有効範囲）によりブロック内部のみ。
ブロックの外部で作成した変数はブロック内部でも使用可能。
もしブロック内変数とブロック外変数が同じならば、ブロック内ならブロック引数が優先される。

#### do end と{}
ブロックはdo endだけでなく、{}で囲ってもブロックを作ることができる。
do end と{}は同じブロックなので、{}を使いブロック内部を改行されることも可能。

* 開業を含む長いブロックを記載する場合はdo end
* 1行でコンパクトに書きたい場合は{}

### ブロックを使用した配列のメソッド

#### map/collect
mapメソッドは各要素に対しブロックを評価、その後結果を新しい配列にして返す。

```
numbers = [1, 2, 3, 4, 5]
new_numbers = numbers.map {|n| n * 10}
new_numbers
#=> [10, 20, 30, 40, 50]
```

#### select/find_all/reject
selectメソッドは各要素に対しブロックを評価、その戻り値が真の要素を集めた配列を返す。
rejectはこの反対。

```
numbers = [1, 2, 3, 4, 5]
even_numbers = numbers.select {|n| n.even?}
even_numbers
#=> [2, 4]
```

```
numbers = [1, 2, 3, 4, 5]
odd_numbers = numbers.reject {|n| n.even?}
odd_numbers
#=> [1, 3, 5]
```

#### find/detect
findメソッドはブロックの戻り値が真になった最初の要素を返す。

```
numbers = [1, 2, 3, 4, 5]
even_number = numbers.find {|n| n.even?}
even_number
#=> [2]
```

#### inject/reduce
injectメソッドはたたみこみ演算を行うメソッド。
以下は
0+1=1
1+2=3
3+3=6
6+4=10
を行なっている。

```
numbers = [1, 2, 3, 4]
sum = numbers.inject(0) { |result, n| result + n }
sum
#=> [10]
```

#### &とシンボルで簡潔に
ブロック変数に代わり&:メソッド名という引数を渡している。
【条件】
1. ブロック引数が1つ。
2. ブロックの中で呼び出すメソッドに引数はない。
3. ブロックの中で、ブロック引数に対してメソッドを1回呼び出す以外の処理がない。

```
[1, 2, 3, 4, 5, 6].select {&:odd?}
#=> [1,3,5]
```

### Range(範囲)
値の範囲を表すオブジェクト。
範囲オブジェクトは..または...を使って作成する。

..と...の違いは最後の値を範囲に含めるか含めないかの違い。
..は含む、...は含まない。

#### 配列と文字列の一部を抜き出す
配列に対し添字の代わりにい範囲オブジェクトを渡すと、指定した範囲の要素を取得可能。

```
a = [1, 2, 3, 4, 5]
a[1..3]
#=> [2,3,4]
```

```
a = "abcdefg"
a[1..3]
#=> "bcd"
```

#### 範囲の判定
n以上m以下、n以上m未満の判定は、不等号より範囲の方が便利

#### case文での使用例

```
def charge(age)
  case age
  when 0..5
    0
  when 6..12
    300
  when 13..18
    600
  else
    1000
  end
end
```

#### 値が連続する配列を作成

```
(1..5).to_a
#=> [1, 2, 3, 4, 5]
```

#### 繰り返し処理

```
sum = 0
(1..4).each { |n| sum += n }
#=> [10]
```

### テスト駆動開発のサイクル
1. テストを書く。
2. テストが失敗することを確認する。
3. 1つのテストをパスさせるための仮実装を書く。
4. テストがパスすることを確認する。
5. 別のテストパターンを書く。
6. テストが失敗することを確認する。
7. 仮実装ではなく、ちゃんとしたロジックを書く。
8. テストがパスすることを確認する。
9. ロジックをリファクタリングする。
10. テストがパスすることを確認する。

テスト駆動開発のポイント
* 先にテストを書いて失敗させる。
* テストがパスするような最小限のコードを書く。
* リファクタリングする。

### 配列について

#### 配列の要素取得方法
添字を2つ使用することで、添字の位置と取得する長さを指定。
またRubyでは添字に負の値が使用可能。

* value_atメソッド: 取得したい要素の添字を複数指定。
* lastメソッド: 配列の最後の要素を取得。
* firstメソッド: 配列の最初の要素を取得。

#### 配列の要素変更方法
Rubyでは添字に負の値が使用して要素の変更が可能。

* pushメソッド: <<と同じ。配列に要素を追加。
* deleteメソッド: 指定した値に一致する要素を削除。

#### 配列の連結
concatメソッド: 2つの配列を連結。この場合元の配列が変更される。(破壊的)
※ +を使用し配列を連結した場合、元の配列は変更せず新たに配列を作成。(非破壊的)

#### 配列のさまざまな集合
* |: 和集合
* -: 差集合
* &: 積集合

Setクラス: 配列より効率的に集合を扱える。

#### メソッドの可変長引数
個数に制限のない引数のこと。
引数の前に*をつける。

#### 配列における「==」
配列の左辺、右辺が等しいか判定。

#### %記法
[]の代わりに%wまたは%Wでも配列をつくることができる。（文字列のみ）

```
%w!apple, melon, orange!
%w(apple, melon, orange)
```
式展開や改行文字、タブ文字を使いたい場合は%Wとなる。

#### 配列の文字列変換
* charsメソッド: 文字列中の1文字1文字を配列の要素に分解する。
* splitメソッド: 引数で渡した区切り文字で文字列を配列に分割する

#### 配列への初期値設定
[]とArray.newは同じ。
第一引数だけではnil。第二引数を渡すとnil以外の初期値を設定できる。
(ただし、配列の全要素が同じ文字列オブジェクトを参照しているので、オブジェクトが変更されると他の要素も変更されるので注意が必要)

Array.newではブロックを使っての初期値設定もできる。

#### ミュータブルとイミュータブル
ミュータブル: 変更可能か
* 破壊的な変更が可能。
* freezeメソッドを使用すると、変更不可に変更できる。

イミュータブル: 変更不可能か
* 破壊的な変更が不可能。
* Integer, Floatクラス
* Symbolクラス
* TrueとFalseクラス
* Nilクラス

### ブロックについて

#### 添字付きの繰り返し処理
* each_with_indexメソッド: ブロック引数の第2引数に添字を渡す。
添字は0から始まるが、each_with_index(1)とすることで、0以外の数字から始めることができる。

#### with_indexメソッドの応用
* with_indexメソッド: map, delete_if, eachなどのメソッドと組み合わせることができる。
with_indexはEnumeratorクラスのインスタンスメソッド。

#### 配列がブロック引数にわたる場合
配列の中の配列をeachメソッドなどで取り出すと、配列がブロック引数に渡される。
ブロック引数を2つにすると、縦と横の値を別々に受け取ることができる。

#### ブロックローカル変数
ブロック引数に;を付与し続けて変数を宣言すると、ブロック内でのみ有効なローカル変数を宣言できる。

#### File.openメソッド
File.openメソッドといった外部リソースを使用するメソッドにおいてもブロックが使用できる。

```
File.open("./sample.txt","w") do |file|
  file.puts("1行目のテキストです。")
end
```

#### 結合度
do endより{}の方が結合度が高い。

a = [1, 2, 3]
a.delete(100)
#=> nil

a.delete 100 do
  "NG"
end
#=> NG

a.delete 100 { "NG" }
#=> SyntaxError

### 様々な繰り返し処理

#### timesメソッド
配列を使用せず、単純にn回繰り返すメソッド。(Integerクラスのメソッド)

#### uptoメソッドとdowntoメソッド
nからmまで数字を1つずつ増やしながら処理を繰り返すメソッド。(Integerクラスのメソッド)
nからmまで数字を1つずつ減らしながら処理を繰り返すメソッド。(Integerクラスのメソッド)

#### stepメソッド
1,3,5,というように、nからmまで数字をxつずつ増やしながら処理を繰り返すメソッド。(Numericクラスのメソッド)

#### while文とuntil文
繰り返し処理用構文while。指定した条件が真である限り処理を繰り返す。
繰り返し処理用構文while。指定した条件が偽である限り処理を繰り返す。

#### for文
配列やハッシュはfor文で繰り返し処理も行える。
実質的にeachメソッドとほぼ同じ動きをするがm、for文は配列の要素を受け取る変数やfor文内のローカル変数がfor文の外でも使える。

#### loopメソッド
無限ループを作るメソッド。(Karnelモジュール)
ブロックも使用可能。

### 繰り返し処理の制御構文

#### break
繰り返し処理の脱出。
breakに引数を渡すと、whileやfor文の戻り値になり、引数がなければnilとなる。

#### throwとcatch
Kernelモジュールのthrowとcatchはループそのものからに抜け出せる。

#### breakとreturnの違い
breakは「繰り返し処理からの脱出」
returnは「繰り返しだけでなくメソッドからの脱出」

#### next
繰り返し処理を中断し、次の繰り返し処理を実行する。

#### redo
繰り返し処理をやり直す。